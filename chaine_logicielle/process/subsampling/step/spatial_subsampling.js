var spawn = require('child_process').spawn;
var fs = require('fs');

var StepSpatialSubsampling = inherit(Step, {
    run: function() {
        var self = this;
        console.log('Début de l\'etape ' + this.getName());
        var inputFile = 'input.ply';
        
        /*
         * Il nous faut le nom du fichier en sortie, qui est composé du nom du fichier en entrée + _SPATIAL_SUBSAMPLED + la nouvelle extension
         */
        var splitInput = inputFile.split('.');
        splitInput.pop();
        var outputFile = splitInput.join('.') + '_SPATIAL_SUBSAMPLED.asc';
        
        // TODO: passage des noms de fichiers entre Process
        // TODO: passage de la densité en paramètre modifiable par l'utilisateur
        this.process = spawn('cloudcompare', ['-NO_TIMESTAMP', '-C_EXPORT_FMT', 'ASC', '-PREC', '12', '-SEP', 'SPACE', '-O', inputFile, '-SS', 'SPATIAL', '0.1']);
        this.process.on('error', function(err) {
            console.log('[ERREUR] SpatialSubsampling: ' + err);
        });
        this.watcher = fs.watch(outputFile, function(event) {
            if(event == 'change') {
                // si la taille du fichier a changé, ou si sa date de dernière modification a changé, on reset le timer
                clearTimeout(self.timeout);
                self.timeout = setTimeout(self.processDone, 10000);
            }
        });
    },
    processDone: function() {
        console.log('finished');
    },
    
    getName: function() {
        return "Subsampling";
    },
    clean: function() {
        this.watcher.close();
    },
    
    processLine: function(line) {
        if(this.__base(line)) {
            // TODO: progression
            // TODO: gérer erreur :
            // [LINE] ERROR: no points generated by pmvs2
            // [LINE] ERROR: pmvs2 crashed? not enough memory? 32bit?
            // 
            // PMVS génère des clusters d'au maximum x images
            // un cluster de x images prend en moyenne x secondes
            // rechercher et établir la progression grâce à ces données
            // faire une régression linéaire si le nb d'img dans le cluster est < au max
            var matches = /^Undistorting ([0-9]+) images/.exec(line);
            if(matches) {
                // TODO: rajouter un poids suivant le nombre de clusters prévus à partir du nombre d'images
                this.totalEvents = matches[1];
                this.vsfm.updateProgress((this.internalProgress / this.totalEvents) * 100);
            }
            else {
                var matches2 = /^#[0-9]+: /.exec(line);
                if(matches2) {
                    this.internalProgress++;
                    this.vsfm.updateProgress((this.internalProgress / this.totalEvents) * 100);
                }
            }
            return true;
        }
        return false;
    }
});